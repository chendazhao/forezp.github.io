---
layout: post
title:  "java8 lambda"
categories: java
tags:  java
---

* content
{:toc}

### 0x00 前言

朕虽花心，却深明事理。一山不容二虎，一国不容二母！因此不论朕有多少爱妃（我是逗逼啊，怎么可能还有爱妃，一个皇后就够了！），但是朕的皇后只有一个，这点毋庸置疑。

那么如何来体现朕的皇后的唯一性呢？就是单例模式了！

### 0x01 宫女请安

在朕的后宫中，皇后当之无愧的是天下第一（朕只能当第二），为了彰显皇后在后宫的地位，每日早晨，宫女必须向皇后娘娘请安。

一大群宫女每天都要来向皇后请安，皇后每天也要接见这群小妹妹们。由于皇后的唯一性，众妹妹在请安的时候都会大呼“皇后娘娘千岁！”，注意，大家称呼的是皇后娘娘，而不是张皇后、李皇后什么的。天天向一个皇后请安，也就不会把自己弄迷糊了。这点在设计领域中就要求，一个类只能生成一个对象。

那么怎么来实现呢？对象的产生是通过new关键字完成的（这是主要方式），这个怎么来控制呢？构造函数！在使用new关键字创建对象的时候，都会根据输入参数调用相应的构造函数，如果我们把皇后的构造函数设置成private私有访问权限是不是就可以禁止外部创建对象了？

下图就是宫女向唯一的皇后请安的过程。

![](http://oaurstf0m.bkt.clouddn.com/design_pattern_singleton_queen_maid.png)

只有两个类：Queen代表皇后，Maid代表宫女。

#### 1.代码清单 皇后类


```
public class Queen {
    private static final Queen queen = new Queen();
    private Queen() {

    }
    public static Queen getInstance() {
        return queen;
    }

    public static void say() {
        System.out.println("本宫是yyj，尔等跪安吧~");
    }
}

```
通过定义一个私有访问权限的构造函数，避免被其他类new出来一个对象，而Queen自己则可以new一个对象出来，其他类对该类的访问都可以通过getInstance获得同一个对象。

现在皇后有了，宫女要出场了。

#### 2.代码清单 宫女类

```

public class Maid {
    public static void main(String[] args) {
        for(int i = 1 ; i < 4; i++) {
            Queen queen = Queen.getInstance();
            System.out.println("今天是第 " + i + " 天请安！");
            queen.say();
        }
    }
}
```
宫女请安的运行结果如下所示。

```
今天是第 1 天请安！
本宫是yyj，尔等跪安吧~
今天是第 2 天请安！
本宫是yyj，尔等跪安吧~
今天是第 3 天请安！
本宫是yyj，尔等跪安吧~

```
宫女每天向皇后请安，每天抬头一看，呦，老熟人了，还是昨天那个皇后，这就是单例模式！

### 0x02 单例模式

#### 1.概念

单例模式（Singleton Pattern）是一个比较简单的模式，其定义如下：

Ensure a class has only one instance, and provide a global point of access to it.（确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。）

#### 2.构建方式

通常单例模式在Java语言中，有两种构建方式：

懒汉方式。指全局的单例实例在第一次被使用时构建。
饿汉方式。指全局的单例实例在类装载时构建。
#### 3.代码清单 饿汉模式

```
 public class Singleton {
    private final static Singleton INSTANCE = new Singleton();

    // Private constructor suppresses   
    private Singleton() {}

    // default public constructor
    public static Singleton getInstance() {
        return INSTANCE;
    }
  }
  
```
#### 4.代码清单 懒汉模式

```
public class Singleton {
    private static volatile Singleton INSTANCE = null;

    // Private constructor suppresses 
    // default public constructor
    private Singleton() {}

    //thread safe and performance  promote 
    public static  Singleton getInstance() {
        if(INSTANCE == null){
             synchronized(Singleton.class){
                 //when more than two threads run into the first null check same time, to avoid instanced more than one time, it needs to be checked again.
                 if(INSTANCE == null){ 
                     INSTANCE = new Singleton();
                  }
              } 
        }
        return INSTANCE;
    }
  }
  
```


### 0x03 扩展

单例模式的一个主要应用场景是保证系统中只有一个实例，但是我们也不必受单例中的“单”字的局限，在有些场景中可能需要的不仅仅是只有一个实例，而是要有有限个实例，这种情况实现的代码仍然是单例模式，只是把单个实例变成了有限个实例而已。

